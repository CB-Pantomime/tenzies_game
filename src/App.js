// importing react and useState and useEffect from, ta-dah...react!
import React, { useState, useEffect }from 'react'
// now our App component has connectivity w/ our styles
import './style.css';
// Our Die component in which our App will initialize 10 of for the game
import Die from './Die'
// Nanoid is a unique string ID generator for JS. This dependency will do some frequent and heavy
// lifting for our game state
import {nanoid} from 'nanoid'
// silly confetti drop for when user wins game
import Confetti from 'react-confetti'

// Our parent component that is being rendered to the page via index.js -> index.html
function App() {

  // setting state for our dice, initialized w/ allNewDice function so game starts at ready to play state
  const [dice, setDice] = React.useState(allNewDice())

  // to get a single new die, very similar logic to allNewDice function
  // returns a value of random number, that isHeld is false, and a new id from nanoid()
  function getNewDie() {
    return {
      value: Math.ceil(Math.random() * 6),
      isHeld: false,
      id: nanoid()
    }
  }

  // gets 10 all new dice 
  function allNewDice() {
    // our empty array to be filled with die objects generated in for loop
    let newDice = []
    for(let i = 0; i < 10; i++){
      // variable referencing .random() method times six, plus one passed in the .floor() method
      let randomNum = Math.floor(Math.random() * 6 +1);
      // accessing newDice array and pushing in a new die at each iteration of our for loop
      // comprised of value: a random number, isHeld is false, and an id from nanoid()
      newDice.push({
        value:randomNum, 
        isHeld: false,
        id: nanoid()
      })
    }
    // returning newDice allows the function to populate our dice state as initialized
    return newDice
  }

  // holds dice that are clicked by user, takes in a parameter of id at the onClick event in 
  // our Die component <- which is generated as a property in our diceElements variable .map() method
  function holdDice(id) {
    // set dice state: take previous dice states, map over them at each die
    // check if that die.id is the same as the id being passed to our function
    // return that die object in full while updating its isHeld boolean as the opposite of current boolean
    // else just return that die
    setDice( prevDice => prevDice.map( die => {
           if(die.id === id){
              return {
                ...die, 
                isHeld: !die.isHeld
              }
          }else{
              return die
          }
      })
    )
    console.log(`Here is the ID: ${id}`)
  }

  // setting state for our game and initialized as false
  // b/c when the user wins the game it will be flipped to true
  const [tenzies, setTenzies] = React.useState(false)
  
  // after each render on the page check to see if the dice state has changed
  React.useEffect( () => {
     // if it has changed check to see if every dice is held as true
     const allTrue = dice.every( die => die.isHeld )
    //  and check to see if every dice is the same value of die-face number
     const allSame = dice.every( die => die.value )
    //  if both of those are true
     if(allTrue && allSame){
       //  set the game state from false to true
       setTenzies(true)
      //  console.log(`WIN`)
     }
    // console.log(`Dice state changed`)
  }, [dice])

  // generating our Die components by mapping over dice state (which was intitialized to  
  // allNewDice() <- which in turn returns 10 die from the for loop) 
  const diceElements = dice.map((die) => {
      // at each die in map return a Die component and generate these props 
      return (
        <Die 
        // id generated by nanoid() this key is requested by React it can help React identify which items have changed, are added, or are removed. It helps give the element a stable identity
        key={die.id} 
        // our random number for die-face value
        value={die.value}
        // initialized as false so can be flipped to true when holdDice() function is run at click event
        isHeld={die.isHeld}
        // that same id generated by nanoid()
        id={die.id}
        // we have this as an anonymous callback function so we can get the id of 
        // the specfic die-face that is clicked and then hold that die when rolling again
        handleClick={() => holdDice(die.id)}
        />
      )
  })
 
  // to roll dice again during game play
  function rollDice() {
    // but first check if tenzies is not true (user has not won yet)
    if(!tenzies){
      // if it's true that tenzies is still false 
      // set state for dice: take all previous dice, map over them
      // at each die return a new die (by way of getNewDie()) if isHeld is not true
      // b/c if isHeld is true we want to hold that die, not get a new one
      setDice( prevDice =>  prevDice.map( die => {
        return die.isHeld ? 
        die :
        getNewDie()
      }))

    // else if tenzies is true (user has won game)
    }else if(tenzies){
      // set tenzies back to false
      setTenzies(false)
      // and reset game w/ setting dice state back to allNewDice()
      setDice(allNewDice())
    }
   
  }



  return (
    <main>
      {/* if tenzies game state boolean is true that run Confettie component, else do nothing */}
      {tenzies ? <Confetti /> : null }
        <h1 className="title">Tenzies</h1>
        <p className="instructions">Roll until all dice are the same. Click each die to freeze it at its current value between rolls.</p>
        <div className="dice-container">
            {/* to display all of our dice */}
            {diceElements}
        </div>
        <button 
        className="roll-dice" 
        onClick={rollDice}
        >
          {/* if tenzies is true (game was won) then display button text as 'go again?' else display text as roll */}
          {tenzies ? "Go again?" : "Roll"}
          </button>
    </main>
  )
}

export default App;
